<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AniTracker</title>

  <!-- Part 2 will add CSS here -->
  <style id="app-style">
    /* ------------------------------
   GLOBAL SETTINGS
------------------------------ */
:root {
  --bg-dark: #0d0f1a;
  --bg-card-dark: #161a2b;
  --text-light: #e5e7f0;
  --text-muted: #9aa0b8;
  --accent: #4da3ff;
  --accent-glow: rgba(77,163,255,0.45);

  --bg-light: #f5f7ff;
  --bg-card-light: #ffffff;
  --text-dark: #1b1d2a;
}

body {
  margin: 0;
  padding: 0;
  font-family: "Inter", sans-serif;
  background: var(--bg-dark);
  color: var(--text-light);
  transition: background 0.3s ease, color 0.3s ease;
}

body[data-theme="light"] {
  background: var(--bg-light);
  color: var(--text-dark);
}

/* ------------------------------
   HEADER
------------------------------ */
.app-header {
  padding: 18px 22px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: rgba(22,26,43,0.6);
  backdrop-filter: blur(10px);
  position: sticky;
  top: 0;
  z-index: 20;
}

body[data-theme="light"] .app-header {
  background: rgba(255,255,255,0.7);
}

.logo-text {
  font-size: 26px;
  margin: 0;
  font-weight: 700;
  color: var(--accent);
  text-shadow: 0 0 10px var(--accent-glow);
}

.subtitle {
  margin: 0;
  font-size: 13px;
  color: var(--text-muted);
}

.header-right {
  display: flex;
  gap: 10px;
}

.header-btn {
  background: transparent;
  border: 1px solid var(--accent);
  color: var(--accent);
  padding: 6px 12px;
  border-radius: 6px;
  cursor: pointer;
}

.header-btn:hover {
  background: var(--accent);
  color: #fff;
}

.theme-toggle {
  font-size: 20px;
  border: none;
  background: transparent;
  cursor: pointer;
}

/* ------------------------------
   SECTIONS
------------------------------ */
.section-card {
  background: var(--bg-card-dark);
  margin: 18px;
  padding: 18px;
  border-radius: 14px;
  box-shadow: 0 0 12px rgba(0,0,0,0.3);
}

body[data-theme="light"] .section-card {
  background: var(--bg-card-light);
  box-shadow: 0 0 12px rgba(0,0,0,0.1);
}

.section-title {
  margin: 0 0 6px;
  font-size: 22px;
}

.section-subtitle {
  margin: 0 0 16px;
  color: var(--text-muted);
}

/* ------------------------------
   SEARCH BAR
------------------------------ */
.search-row {
  display: flex;
  gap: 10px;
}

.search-input {
  flex: 1;
  padding: 10px;
  border-radius: 8px;
  border: none;
  background: #0f1320;
  color: var(--text-light);
}

body[data-theme="light"] .search-input {
  background: #eef1ff;
  color: var(--text-dark);
}

.primary-btn {
  padding: 10px 16px;
  border-radius: 8px;
  border: none;
  background: var(--accent);
  color: #fff;
  cursor: pointer;
  font-weight: 600;
}

.primary-btn:hover {
  filter: brightness(1.1);
}

/* ------------------------------
   SEARCH RESULT GRID
------------------------------ */
.search-grid,
.anime-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
  gap: 14px;
  margin-top: 18px;
}

.poster-card {
  background: #111526;
  border-radius: 10px;
  overflow: hidden;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
}

.poster-card:hover {
  transform: scale(1.05);
  box-shadow: 0 0 15px var(--accent-glow);
}

.poster {
  width: 100%;
  height: 180px;
  object-fit: cover;
}

.poster-info {
  padding: 8px;
}

.poster-title {
  font-size: 14px;
  font-weight: 600;
  margin: 0;
}

.genre-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin-top: 6px;
}

.genre-tag {
  background: rgba(255,255,255,0.09);
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 11px;
  color: var(--text-muted);
}

body[data-theme="light"] .genre-tag {
  background: rgba(0,0,0,0.08);
  color: #555;
}

/* ------------------------------
   LIBRARY TABS
------------------------------ */
.status-tabs {
  display: flex;
  gap: 8px;
  margin-bottom: 14px;
}

.tab {
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid #3a3f55;
  background: transparent;
  color: var(--text-light);
  cursor: pointer;
}

body[data-theme="light"] .tab {
  color: var(--text-dark);
  border-color: #ccc;
}

.tab.active {
  background: var(--accent);
  border-color: var(--accent);
  color: #fff;
}

.empty-note {
  text-align: center;
  color: var(--text-muted);
  padding: 12px;
}

/* ------------------------------
   CONTINUE WATCHING
------------------------------ */
.horizontal-grid {
  display: flex;
  overflow-x: auto;
  gap: 14px;
  padding-bottom: 10px;
}

.horizontal-grid::-webkit-scrollbar {
  height: 6px;
}

.horizontal-grid::-webkit-scrollbar-thumb {
  background: var(--accent);
  border-radius: 10px;
}

/* ------------------------------
   STATS
------------------------------ */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
  gap: 14px;
}

.stat-box {
  text-align: center;
  background: #111526;
  padding: 14px 10px;
  border-radius: 10px;
}

body[data-theme="light"] .stat-box {
  background: #f0f3ff;
}

.stat-box h3 {
  margin: 0;
  font-size: 22px;
  color: var(--accent);
}

/* ------------------------------
   MODAL
------------------------------ */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.65);
  backdrop-filter: blur(3px);
  display: flex;
  justify-content: center;
  align-items: center;
}

.hidden {
  display: none !important;
}

.modal-content {
  background: var(--bg-card-dark);
  padding: 20px;
  width: 90%;
  max-width: 420px;
  border-radius: 12px;
  max-height: 80vh;
  overflow-y: auto;
}

body[data-theme="light"] .modal-content {
  background: var(--bg-card-light);
}

.modal-close {
  background: transparent;
  border: none;
  font-size: 20px;
  float: right;
  cursor: pointer;
}

/* ------------------------------
   FOOTER
------------------------------ */
.footer {
  padding: 14px;
  text-align: center;
  color: var(--text-muted);
    }
  </style>
</head>

<body data-theme="dark">
  <div id="app-root">

    <!-- HEADER -->
    <header class="app-header">
      <div class="header-left">
        <h1 class="logo-text">AniTracker</h1>
        <p class="subtitle">Your personal anime dashboard</p>
      </div>

      <div class="header-right">
        <!-- THEME TOGGLE -->
        <button id="theme-toggle" class="theme-toggle">üåô</button>

        <!-- BACKUP BUTTON -->
        <button id="export-button" class="header-btn">Backup</button>
        <input id="import-file" type="file" accept="application/json" hidden />
        <button id="import-button" class="header-btn">Import</button>
      </div>
    </header>

    <!-- SEARCH SECTION -->
    <section class="section-card">
      <h2 class="section-title">Search Anime</h2>
      <p class="section-subtitle">Find anime with posters, ratings, genres & watch order</p>

      <div class="search-row">
        <input id="search-input" class="search-input" placeholder="Search anime (e.g. 'Attack on Titan')" />
        <button id="search-button" class="primary-btn">Search</button>
      </div>

      <div id="search-results" class="search-grid"></div>
    </section>

    <!-- DETAILS MODAL -->
    <div id="details-modal" class="modal hidden">
      <div class="modal-content">
        <button id="modal-close" class="modal-close">‚úñ</button>
        <div id="modal-body"></div>
      </div>
    </div>

    <!-- CONTINUE WATCHING ROW -->
    <section class="section-card">
      <h2 class="section-title">Continue Watching</h2>
      <div id="continue-grid" class="horizontal-grid"></div>
    </section>

    <!-- LIBRARY -->
    <section class="section-card">
      <h2 class="section-title">Your Library</h2>
      <p class="section-subtitle">Automatically grouped by status</p>

      <div class="status-tabs">
        <button data-status="all" class="tab active">All</button>
        <button data-status="watching" class="tab">Watching</button>
        <button data-status="completed" class="tab">Completed</button>
        <button data-status="plan" class="tab">Plan to Watch</button>
        <button data-status="dropped" class="tab">Dropped</button>
        <button data-status="rewatching" class="tab">Rewatching</button>
      </div>

      <div id="library-grid" class="anime-grid"></div>
      <p id="library-empty" class="empty-note">Your list is empty. Add anime from search.</p>
    </section>

    <!-- STATS SECTION -->
    <section class="section-card">
      <h2 class="section-title">Your Stats</h2>

      <div class="stats-grid">
        <div class="stat-box">
          <h3 id="stat-total">0</h3>
          <p>Total Anime</p>
        </div>
        <div class="stat-box">
          <h3 id="stat-hours">0h</h3>
          <p>Hours Watched</p>
        </div>
        <div class="stat-box">
          <h3 id="stat-genre">‚Äì</h3>
          <p>Top Genre</p>
        </div>
        <div class="stat-box">
          <h3 id="stat-score">0</h3>
          <p>Average Score</p>
        </div>
      </div>
    </section>

    <!-- RECOMMENDATIONS -->
    <section class="section-card">
      <h2 class="section-title">Recommended For You</h2>
      <p class="section-subtitle">Based on your genres & ratings</p>
      <div id="rec-grid" class="anime-grid"></div>
    </section>

    <!-- FOOTER -->
    <footer class="footer">
      AniTracker ‚Ä¢ Built with ‚ù§Ô∏è ‚Ä¢ Data saved locally on your device
    </footer>

  </div>

  <!-- PART 3 + PART 4 WILL GO HERE -->
  <script id="app-script">
    // ================================
// AniTracker ‚Äì State & Utilities
// ================================

const STORAGE_KEY = "anittracker_state_v1";
const THEME_KEY = "anittracker_theme_v1";

let state = {
  library: [],        // anime saved by user
  lastTheme: "dark",
};

let currentFilter = "all";

// Shortcuts
const $ = (id) => document.getElementById(id);

// Save/load state
function saveState() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  } catch (e) {
    console.error("Failed to save", e);
  }
}

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) {
      const parsed = JSON.parse(raw);
      if (parsed && typeof parsed === "object") {
        state = Object.assign(state, parsed);
      }
    }
  } catch (e) {
    console.error("Failed to load", e);
  }
}

// Generate simple ID
function makeId() {
  return "a_" + Math.random().toString(36).slice(2) + Date.now().toString(36);
}

// Genre icons
const GENRE_ICONS = {
  Action: "üî•",
  Adventure: "üó∫Ô∏è",
  Comedy: "üòÇ",
  Drama: "üé≠",
  Fantasy: "‚ú®",
  Horror: "üëª",
  Mystery: "üïµÔ∏è",
  Romance: "‚ù§Ô∏è",
  SciFi: "üöÄ",
  Sports: "üèÜ",
  SliceofLife: "‚òï",
  Supernatural: "üîÆ",
  Psychological: "üß†",
};

// ================================
// Theme handling
// ================================

function applyTheme(theme) {
  document.body.setAttribute("data-theme", theme);
  state.lastTheme = theme;
  localStorage.setItem(THEME_KEY, theme);

  const btn = $("theme-toggle");
  if (btn) btn.textContent = theme === "dark" ? "üåô" : "‚òÄÔ∏è";
}

function initTheme() {
  const saved = localStorage.getItem(THEME_KEY);
  applyTheme(saved === "light" ? "light" : "dark");

  $("theme-toggle").onclick = () => {
    const next = document.body.getAttribute("data-theme") === "dark" ? "light" : "dark";
    applyTheme(next);
  };
}

// ================================
// Library data helpers
// ================================

function upsertAnime(anime) {
  const idx = state.library.findIndex((a) =>
    (anime.malId && a.malId === anime.malId) ||
    (anime.id && a.id === anime.id)
  );

  if (idx >= 0) {
    state.library[idx] = Object.assign({}, state.library[idx], anime);
  } else {
    anime.id = anime.id || makeId();
    anime.episodesWatched = anime.episodesWatched || 0;
    anime.status = anime.status || "plan";
    anime.minutesPerEp = anime.minutesPerEp || 24;
    state.library.push(anime);
  }

  saveState();
  renderAll();
}

function removeAnime(id) {
  state.library = state.library.filter((a) => a.id !== id);
  saveState();
  renderAll();
}

// ================================
// Rendering: Library + Continue Watching
// ================================

function renderLibrary() {
  const grid = $("library-grid");
  const empty = $("library-empty");
  grid.innerHTML = "";

  let list = state.library.slice();
  if (currentFilter !== "all") {
    list = list.filter((a) => a.status === currentFilter);
  }

  if (!list.length) {
    empty.style.display = "block";
    return;
  }
  empty.style.display = "none";

  list.forEach((anime) => {
    const card = document.createElement("div");
    card.className = "poster-card";

    const img = document.createElement("img");
    img.className = "poster";
    img.src = anime.image || "";
    img.alt = anime.title;
    card.appendChild(img);

    const info = document.createElement("div");
    info.className = "poster-info";

    const title = document.createElement("p");
    title.className = "poster-title";
    title.textContent = anime.title;
    info.appendChild(title);

    const meta = document.createElement("p");
    meta.style.fontSize = "12px";
    meta.textContent =
      (anime.type || "TV") +
      " ‚Ä¢ " +
      (anime.episodes || "?") +
      " eps ‚Ä¢ Score " +
      (anime.score ?? "?");
    info.appendChild(meta);

    const prog = document.createElement("p");
    prog.style.fontSize = "12px";
    prog.textContent =
      "Ep " +
      (anime.episodesWatched || 0) +
      " / " +
      (anime.episodes || "?");
    info.appendChild(prog);

    const genresDiv = document.createElement("div");
    genresDiv.className = "genre-tags";
    (anime.genres || []).forEach((g) => {
      const tag = document.createElement("span");
      tag.className = "genre-tag";
      const key = g.replace(/\s+/g, "");
      const emoji = GENRE_ICONS[key] || "";
      tag.textContent = (emoji ? emoji + " " : "") + g;
      genresDiv.appendChild(tag);
    });
    info.appendChild(genresDiv);

    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.flexWrap = "wrap";
    controls.style.gap = "4px";
    controls.style.marginTop = "6px";

    const plusBtn = document.createElement("button");
    plusBtn.className = "primary-btn";
    plusBtn.style.padding = "4px 8px";
    plusBtn.style.fontSize = "11px";
    plusBtn.textContent = "+1 ep";
    plusBtn.onclick = (e) => {
      e.stopPropagation();
      anime.episodesWatched = (anime.episodesWatched || 0) + 1;
      saveState();
      renderAll();
    };
    controls.appendChild(plusBtn);

    const statusSel = document.createElement("select");
    statusSel.style.padding = "4px 8px";
    statusSel.style.fontSize = "11px";
    ["watching", "completed", "plan", "rewatching", "dropped"].forEach((s) => {
      const opt = document.createElement("option");
      opt.value = s;
      opt.textContent = s;
      if (anime.status === s) opt.selected = true;
      statusSel.appendChild(opt);
    });
    statusSel.onchange = (e) => {
      anime.status = e.target.value;
      saveState();
      renderAll();
    };
    controls.appendChild(statusSel);

    const removeBtn = document.createElement("button");
    removeBtn.className = "header-btn";
    removeBtn.style.padding = "4px 8px";
    removeBtn.style.fontSize = "11px";
    removeBtn.textContent = "Remove";
    removeBtn.onclick = (e) => {
      e.stopPropagation();
      if (confirm("Remove from library?")) removeAnime(anime.id);
    };
    controls.appendChild(removeBtn);

    info.appendChild(controls);

    card.appendChild(info);
    card.onclick = () => openDetailsFromLibrary(anime);

    grid.appendChild(card);
  });
}

function renderContinueWatching() {
  const row = $("continue-grid");
  row.innerHTML = "";

  const watching = state.library.filter(
    (a) => a.status === "watching" || a.status === "rewatching"
  );

  if (!watching.length) {
    row.textContent = "No shows in progress.";
    return;
  }

  watching.forEach((anim) => {
    const card = document.createElement("div");
    card.className = "poster-card";

    const img = document.createElement("img");
    img.className = "poster";
    img.src = anim.image || "";
    img.alt = anim.title;
    card.appendChild(img);

    const info = document.createElement("div");
    info.className = "poster-info";

    const title = document.createElement("p");
    title.className = "poster-title";
    title.textContent = anim.title;
    info.appendChild(title);

    const prog = document.createElement("p");
    prog.style.fontSize = "12px";
    prog.textContent =
      "Ep " +
      (anim.episodesWatched || 0) +
      " / " +
      (anim.episodes || "?");
    info.appendChild(prog);

    const btn = document.createElement("button");
    btn.className = "primary-btn";
    btn.style.padding = "4px 8px";
    btn.style.fontSize = "11px";
    btn.textContent = "+1 ep";
    btn.onclick = (e) => {
      e.stopPropagation();
      anim.episodesWatched = (anim.episodesWatched || 0) + 1;
      saveState();
      renderAll();
    };
    info.appendChild(btn);

    card.appendChild(info);
    card.onclick = () => openDetailsFromLibrary(anim);

    row.appendChild(card);
  });
                         }
    // ================================
// Stats & Recommendations
// ================================

function renderStats() {
  const list = state.library;
  $("stat-total").textContent = list.length.toString();

  let minutes = 0;
  let sumScore = 0;
  let scoreCount = 0;
  const genreFreq = {};

  list.forEach((a) => {
    const watched = a.episodesWatched || 0;
    const mins = a.minutesPerEp || 24;
    minutes += watched * mins;

    if (a.score != null) {
      sumScore += a.score;
      scoreCount++;
    }

    (a.genres || []).forEach((g) => {
      genreFreq[g] = (genreFreq[g] || 0) + 1;
    });
  });

  $("stat-hours").textContent = (Math.round((minutes / 60) * 10) / 10) + "h";

  let top = "-";
  let mx = 0;
  Object.entries(genreFreq).forEach(([g, c]) => {
    if (c > mx) {
      mx = c;
      top = g;
    }
  });
  $("stat-genre").textContent = top;

  $("stat-score").textContent =
    scoreCount ? (sumScore / scoreCount).toFixed(2) : "0.00";
}

function renderRecommendations() {
  const grid = $("rec-grid");
  grid.innerHTML = "";

  if (!state.library.length) {
    grid.textContent = "Add anime to your library for recommendations.";
    return;
  }

  const freq = {};
  state.library.forEach((a) => {
    (a.genres || []).forEach((g) => {
      freq[g] = (freq[g] || 0) + 1;
    });
  });

  let topGenre = null;
  let max = 0;
  Object.entries(freq).forEach(([g, c]) => {
    if (c > max) {
      max = c;
      topGenre = g;
    }
  });

  const recs = state.library
    .filter((a) => (a.genres || []).includes(topGenre))
    .sort((a, b) => (b.score || 0) - (a.score || 0))
    .slice(0, 8);

  if (!recs.length) {
    grid.textContent = "Not enough data to recommend yet.";
    return;
  }

  recs.forEach((anime) => {
    const card = document.createElement("div");
    card.className = "poster-card";

    card.onclick = () => openDetailsFromLibrary(anime);

    const img = document.createElement("img");
    img.className = "poster";
    img.src = anime.image || "";
    img.alt = anime.title;
    card.appendChild(img);

    const info = document.createElement("div");
    info.className = "poster-info";

    const title = document.createElement("p");
    title.className = "poster-title";
    title.textContent = anime.title;
    info.appendChild(title);

    const meta = document.createElement("p");
    meta.style.fontSize = "12px";
    meta.textContent = "Score " + (anime.score ?? "?");
    info.appendChild(meta);

    card.appendChild(info);
    grid.appendChild(card);
  });
}

// ================================
// Search (Jikan API)
// ================================

function searchAnime(query) {
  const url =
    "https://api.jikan.moe/v4/anime?q=" +
    encodeURIComponent(query) +
    "&limit=12&order_by=popularity&sort=asc";

  return fetch(url).then((res) => res.json());
}

function fetchAnimeFull(malId) {
  return fetch("https://api.jikan.moe/v4/anime/" + malId + "/full")
    .then((res) => res.json());
}

function renderSearchResults(found) {
  const container = $("search-results");
  container.innerHTML = "";

  if (!found.length) {
    container.textContent = "No results.";
    return;
  }

  const processed = found
    .map((item) => ({
      ...item,
      displayTitle: item.title_english || item.title || item.title_japanese,
    }))
    // only main series (TV)
    .filter((item) => item.type === "TV" || item.type === "TV Series");

  if (!processed.length) {
    container.textContent = "No main series found.";
    return;
  }

  processed.forEach((d) => {
    const card = document.createElement("div");
    card.className = "poster-card";

    card.onclick = () => openDetailsFromSearch(d.mal_id);

    const img = document.createElement("img");
    img.className = "poster";
    img.src = d.images?.jpg?.image_url || "";
    img.alt = d.displayTitle;
    card.appendChild(img);

    const info = document.createElement("div");
    info.className = "poster-info";

    const title = document.createElement("p");
    title.className = "poster-title";
    title.textContent = d.displayTitle;
    info.appendChild(title);

    const meta = document.createElement("p");
    meta.style.fontSize = "12px";
    meta.textContent =
      d.type +
      " ‚Ä¢ " +
      (d.episodes || "?") +
      " eps ‚Ä¢ Score " +
      (d.score ?? "?");
    info.appendChild(meta);

    const genres = document.createElement("div");
    genres.className = "genre-tags";
    (d.genres || []).forEach((g) => {
      const tag = document.createElement("span");
      tag.className = "genre-tag";
      const key = g.name.replace(/\s+/g, "");
      const emoji = GENRE_ICONS[key] || "";
      tag.textContent = (emoji ? emoji + " " : "") + g.name;
      genres.appendChild(tag);
    });
    info.appendChild(genres);

    card.appendChild(info);
    container.appendChild(card);
  });
}

// ================================
// Modal + Detailed View
// ================================

function openModal() {
  $("details-modal").classList.remove("hidden");
}

function closeModal() {
  $("details-modal").classList.add("hidden");
  $("modal-body").innerHTML = "";
}

// Watch order builder
function buildWatchOrder(relations) {
  if (!relations || !relations.length) {
    return "<p>No related anime info.</p>";
  }

  const buckets = {
    Prequel: [],
    "Main story": [],
    Sequel: [],
    "Side story": [],
    Summary: [],
    Other: [],
  };

  relations.forEach((block) => {
    const rel = block.relation;
    (block.entry || []).forEach((e) => {
      if (buckets[rel]) buckets[rel].push(e.name);
      else buckets.Other.push(e.name);
    });
  });

  let html = "<ul>";
  ["Prequel", "Main story", "Sequel", "Side story", "Summary", "Other"].forEach(
    (k) => {
      if (buckets[k].length) {
        html += `<li><strong>${k}:</strong> ${buckets[k].join(", ")}</li>`;
      }
    }
  );
  html += "</ul>";

  return html;
}

function openDetailsFromSearch(malId) {
  const body = $("modal-body");
  body.innerHTML = "Loading‚Ä¶";
  openModal();

  fetchAnimeFull(malId)
    .then((res) => {
      const d = res.data;
      if (!d) throw new Error("No data");

      const title = d.title_english || d.title || d.title_japanese;
      const img = d.images?.jpg?.image_url || "";
      const genres = (d.genres || []).map((g) => g.name);
      const synopsis = d.synopsis || "No synopsis.";

      let html = `
        <div style="display:flex; gap:10px; margin-bottom:10px;">
          <img src="${img}" style="width:90px; border-radius:8px;">
          <div>
            <h2 style="margin:0 0 4px;">${title}</h2>
            <p style="margin:0; font-size:13px;">
              ${d.type} ‚Ä¢ ${d.episodes || "?"} eps ‚Ä¢ Score ${d.score ?? "?"}
            </p>
            <p style="margin:4px 0; font-size:12px; color:#9aa0b8;">${genres.join(", ")}</p>
          </div>
        </div>

        <p style="font-size:12px;">${synopsis}</p>

        <h3 style="margin-top:12px;">Watch Order</h3>
        ${buildWatchOrder(d.relations)}

        <button id="add-to-library" class="primary-btn" style="margin-top:12px; width:100%;">
          Add to Library
        </button>
      `;

      body.innerHTML = html;

      $("add-to-library").onclick = () => {
        upsertAnime({
          malId: d.mal_id,
          title,
          image: img,
          type: d.type,
          episodes: d.episodes || null,
          score: d.score ?? null,
          genres,
          status: "watching",
          episodesWatched: 0,
          minutesPerEp: 24,
        });
        alert("Added to library!");
      };
    })
    .catch(() => {
      body.textContent = "Failed to load details.";
    });
}

function openDetailsFromLibrary(a) {
  const body = $("modal-body");
  const genres = (a.genres || []).join(", ");

  let html = `
    <div style="display:flex; gap:10px; margin-bottom:10px;">
      <img src="${a.image}" style="width:90px; border-radius:8px;">
      <div>
        <h2 style="margin:0 0 4px;">${a.title}</h2>
        <p style="margin:0; font-size:13px;">
          ${a.type} ‚Ä¢ ${a.episodes || "?"} eps ‚Ä¢ Score ${a.score ?? "?"}
        </p>
        <p style="margin:4px 0; font-size:12px; color:#9aa0b8;">${genres}</p>
        <p style="margin:4px 0; font-size:12px;">Status: ${a.status}</p>
      </div>
    </div>

    <p style="font-size:12px;">Use the controls in your Library to change progress or status.</p>
  `;

  body.innerHTML = html;
  openModal();
      }
    // ================================
// Backup / Import
// ================================

function initBackup() {
  const exportBtn = $("export-button");
  const importBtn = $("import-button");
  const importFile = $("import-file");

  exportBtn.onclick = () => {
    try {
      const blob = new Blob([JSON.stringify(state, null, 2)], {
        type: "application/json",
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "anittracker-backup.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    } catch (e) {
      console.error(e);
      alert("Backup failed.");
    }
  };

  importBtn.onclick = () => {
    importFile.click();
  };

  importFile.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const parsed = JSON.parse(ev.target.result);
        if (parsed && typeof parsed === "object" && Array.isArray(parsed.library)) {
          state = parsed;
          saveState();
          renderAll();
          alert("Import successful.");
        } else {
          alert("Invalid file.");
        }
      } catch (err) {
        console.error(err);
        alert("Failed to import.");
      }
    };
    reader.readAsText(file);
  };
}

// ================================
// Filter tabs
// ================================

function initTabs() {
  const tabs = document.querySelectorAll(".status-tabs .tab");
  tabs.forEach((tab) => {
    tab.onclick = () => {
      tabs.forEach((t) => t.classList.remove("active"));
      tab.classList.add("active");
      currentFilter = tab.getAttribute("data-status");
      renderLibrary();
    };
  });
}

// ================================
// Search button handler
// ================================

function initSearch() {
  const btn = $("search-button");
  const input = $("search-input");
  const results = $("search-results");

  btn.onclick = () => {
    const q = input.value.trim();
    results.innerHTML = "";
    if (!q) {
      results.textContent = "Type an anime name.";
      return;
    }
    results.textContent = "Searching‚Ä¶";

    searchAnime(q)
      .then((res) => {
        renderSearchResults(res.data || []);
      })
      .catch((e) => {
        console.error(e);
        results.textContent = "Search failed.";
      });
  };
}

// ================================
// Render all + App init
// ================================

function renderAll() {
  renderLibrary();
  renderContinueWatching();
  renderStats();
  renderRecommendations();
}

document.addEventListener("DOMContentLoaded", () => {
  loadState();
  initTheme();
  initTabs();
  initSearch();
  initBackup();

  $("modal-close").onclick = closeModal;
  $("details-modal").onclick = (e) => {
    if (e.target.id === "details-modal") closeModal();
  };

  renderAll();
});
  </script>

</body>
  </html>
